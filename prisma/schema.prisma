// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // output   = "../node_modules/.prisma/client" // Optionnel: spécifier le chemin de sortie si besoin
}

datasource db {
  provider = "postgresql" // Ou "mysql", "sqlite", "sqlserver" selon votre BDD
  url      = env("DATABASE_URL")
}

// Modèle pour les utilisateurs
model User {
  id           String        @id @default(cuid())
  email        String        @unique
  name         String?
  password     String // Hashed password
  role         UserRole      @default(USER)
  banned       Boolean       @default(false)
  bannedReason String? // Reason for banning
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  tournaments  Tournament[] // Tournois créés par l'utilisateur
  tournamentSessions TournamentSession[] // Active tournament sessions
  votes        Vote[] // Votes from this user
  ActivityLog  ActivityLog[]
  passwordResetTokens PasswordResetToken[]
  sessions     UserSession[] // Active user sessions
}

enum UserRole {
  USER
  ADMIN
  VIP
  SUPERADMIN
}

// Modèle pour les Tournois
model Tournament {
  id          String   @id @default(cuid())
  title       String   @unique // Le nom du tournoi devrait être unique pour une meilleure identification
  description String? // Description optionnelle du tournoi
  status      Status   @default(SETUP) // Statut du tournoi (ex: "en cours", "terminé", etc.)
  // Mode du tournoi: STANDARD (classique) ou TWO_CATEGORY (deux catégories opposées)
  mode        Mode     @default(STANDARD)
  // Catégories utilisées uniquement si mode == TWO_CATEGORY
  categoryA   String?
  categoryB   String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String? // ID de l'utilisateur qui a créé le tournoi (optionnel pour les anciens tournois)
  createdBy   User?    @relation(fields: [createdById], references: [id], onDelete: SetNull)
  Items       Item[] // Liste des items participant à ce tournoi
  sessions    TournamentSession[] // Active tournament sessions
  votes       Vote[] // All votes for this tournament

  @@index([createdById])
  @@index([status])
}

// NEW: Track who is running which tournament on which device
model TournamentSession {
  id            String   @id @default(cuid())
  tournamentId  String
  tournament    Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  
  userId        String   // Who is running this tournament
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  deviceId      String? // Device identifier (browser fingerprint, optional)
  twitchChannel String? // Connected Twitch channel for this session
  
  // State persistence for this user's progress through the tournament
  isActive      Boolean  @default(true) // Is this session currently active
  currentMatchIndex Int @default(0) // Which match this user is on
  currentRoundNumber Int @default(0) // Which round this user is on
  tournamentWinnerId String? // ID of winning item for this user's session (if tournament is complete)
  stateJson     Json? // Full state data (matches, participants, scores, etc.)
  
  startedAt     DateTime @default(now())
  lastActivityAt DateTime @updatedAt
  endedAt       DateTime? // When session ended
  
  createdAt     DateTime @default(now())
  
  @@unique([tournamentId, userId]) // One active session per user per tournament
  @@index([tournamentId])
  @@index([userId])
  @@index([isActive])
}

enum Status {
  SETUP
  LIVE
}

enum Mode {
  STANDARD
  TWO_CATEGORY
}

// Modèle pour les Items (participants du tournoi)
model Item {
  id         String   @id @default(cuid())
  name       String // Nom de l'item
  category   String? // Catégorie (ex: "FR", "US") pour les tournois à deux catégories
  youtubeUrl String? // Lien vers la vidéo YouTube de l'item (optionnel)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tournamentId String
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade) // Si un tournoi est supprimé, ses items le sont aussi
  
  votes      Vote[] // Votes for this item

  @@index([tournamentId]) // Index pour optimiser les requêtes sur le tournoi
}

// Modèle pour le cache des résultats de recherche YouTube
model YoutubeSearchCache {
  id        String   @id @default(cuid())
  query     String // Terme de recherche
  results   Json // Résultats de recherche (stockés en JSON)
  createdAt DateTime @default(now())
  expiresAt DateTime // Date d'expiration du cache

  @@index([query]) // Index sur la requête pour des recherches rapides
  @@index([expiresAt]) // Index sur l'expiration pour nettoyer facilement
}

// Modèle pour les logs d'activité (audit trail)
model ActivityLog {
  id          String   @id @default(cuid())
  userId      String? // ID de l'utilisateur (peut être null pour les actions anonymes)
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  action      String // Type d'action (ex: "item_created", "tournament_published", etc.)
  description String? // Description détaillée de l'action
  entityType  String? // Type d'entité affectée (ex: "tournament", "item")
  entityId    String? // ID de l'entité affectée
  ipAddress   String? // Adresse IP de l'utilisateur
  userAgent   String? // User agent du navigateur
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([entityId])
  @@index([createdAt])
}

// Password reset token for secure password resets
model PasswordResetToken {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  @@index([token])
  @@index([expiresAt])
}

// Modèle pour les votes
model Vote {
  id             String   @id @default(cuid())
  itemId         String   // ID de l'item voté
  item           Item     @relation(fields: [itemId], references: [id], onDelete: Cascade)
  
  tournamentId   String   // ID du tournoi
  tournament     Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  
  // NEW: Track user voting to prevent duplicates
  userId         String?  // Who voted (null for anonymous/pre-auth votes)
  user           User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // NEW: Track which match this vote is for (for deduplication per match)
  matchIndex     Int?     // Which match this vote is for (allows duplicate votes for different matches)
  
  // NEW: For Twitch chat votes - track channel + username
  twitchUsername String?  // Twitch username if voted via chat
  
  createdAt      DateTime @default(now())
  
  @@unique([tournamentId, matchIndex, userId]) // One vote per user per match (for registered users)
  @@unique([tournamentId, matchIndex, twitchUsername]) // One vote per Twitch user per match
  @@index([tournamentId])
  @@index([userId])
  @@index([matchIndex])
  @@index([createdAt])
}

// Modèle pour tracker les sessions utilisateurs actives (GDPR compliant)
model UserSession {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Session tracking
  sessionToken String   @unique // NextAuth session token
  loginAt   DateTime @default(now())
  lastActivity DateTime @updatedAt
  expiresAt DateTime // When session expires
  
  // Device/Browser info
  ipAddress String?
  userAgent String?
  
  // Metadata
  isActive  Boolean  @default(true)
  
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([sessionToken])
  @@index([expiresAt])
  @@index([isActive])
}
